/*****************************************************************************************
 * File: IND_FontManager.cpp
 * Desc: Font manager.
 *****************************************************************************************/

/*********************************** The zlib License ************************************
 *
 * Copyright (c) 2013 Indielib-crossplatform Development Team
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 * distribution.
 *
 *****************************************************************************************/


// ----- Includes -----

#include "Global.h"
#include "Defines.h"
#include "dependencies/tinyxml/tinyxml.h"
#include "IND_FontManager.h"
#include "IND_Font.h"
#include "IND_Surface.h"
#include "IND_Image.h"
#include "IND_ImageManager.h"
#include "IND_Math.h"

// --------------------------------------------------------------------------------
//							  Initialization / Destruction
// --------------------------------------------------------------------------------

/**
 * Returns 1 (true) if the adminstrator is successfully initialized.
 * Must be called before using any method.
 * @param pImageManager					Pointer to the manager IND_ImageManager correctly initialized.
 * @param pSurfaceManager				Pointer to the manager IND_SurfaceManager correctly initialized.
 */
bool IND_FontManager::init(IND_ImageManager *pImageManager, IND_SurfaceManager *pSurfaceManager) {
	end();
	initVars();

	g_debug->header("Initializing FontManager", DebugApi::LogHeaderBegin);

	// Checking IND_SurfaceManager
	if (pSurfaceManager->isOK()) {
		g_debug->header("SurfaceManager Ok", DebugApi::LogHeaderOk);
		_surfaceManager = pSurfaceManager;

		g_debug->header("ImageManager Ok", DebugApi::LogHeaderOk);
		_imageManager = pImageManager;

		_ok = true;

		g_debug->header("FontManager OK", DebugApi::LogHeaderEnd);
	} else {
		g_debug->header("SurfaceManager is not correctly initalized", DebugApi::LogHeaderError);
		_ok = false;
	}

	return _ok;
}

/**
 * Frees the manager and all the objects that it contains.
 */
void IND_FontManager::end() {
	if (_ok) {
		// If the object is loaded, we free it
		g_debug->header("Finalizing FontManager", DebugApi::LogHeaderBegin);
		g_debug->header("Freeing fonts" , DebugApi::LogHeaderBegin);
		freeVars();
		g_debug->header("Fonts freed", DebugApi::LogHeaderEnd);
		g_debug->header("FontManager finalized", DebugApi::LogHeaderEnd);

		_ok = false;
	}
}

/**
 Returns state of initialization.
 @return  Will give true if object initialized correctly, false otherwise
 */
bool IND_FontManager::isOK()            {
    return _ok;
}

// --------------------------------------------------------------------------------
//									Public methods
// --------------------------------------------------------------------------------

/**
 * Returns 1 (true) if the font object passed as a parameter
 * exists and is added successfully to the manager loading the font directly from
 * a graphic file and a configuration file, both generated with MudFont
 * (modified version for IndieLib that can be found in the tools section ).
 * @param pNewFont					Pointer to a font.
 * @param pName                   	Name of the graphic file that contains the font generated by MudFont.
 * @param pFile                   	Name of the configuration file of the font generated by MudFont.
 * @param pType						Font type (see ::IND_Type).
 * @param pQuality					Font quality (see ::IND_Quality).
 */
bool IND_FontManager::addMudFont(IND_Font		*pNewFont,
                                 const char     *pName,
                                 const char     *pFile,
                                 IND_Type		pType,
                                 IND_Quality	pQuality) {
	// Image loading
	IND_Image *mNewImage = IND_Image::newImage();
    bool noImgError = _imageManager->add(mNewImage, pName);
    if (!noImgError) {
        DISPOSEMANAGED(mNewImage);
    }
    
    bool noError(noImgError);

	// IND_Surface creation
	if (noError) {
        noError = addMudFont(pNewFont, mNewImage, pFile, pType, pQuality);
    }
    
    if (noImgError) {
        _imageManager->remove(mNewImage);
    }

	return noError;
}

/**
 * Returns 1 (true) if the font object type 1 passed as a parameter
 * exists and is added successfully to the manager loading the font directly from
 * ::IND_Image object and a configuration file, both generated with MudFont
 * (modified version for IndieLib can be found in the section tools).
 *
 * The posibility of changing the font from an ::IND_Image object is offered in case
 * that you want to change the original font with any modification or filter from
 * ::IND_ImageManager.
 *
 * @param pNewFont					Pointer to a new object type 1 font.
 * @param pImage					Pointer to an object ::IND_Image that contains a previously loaded font from a graphic file generated by MudFont (see tools section).
 * @param pFile						Name of the configuration file of the font generated by MudFont (see tools section).
 * @param pType						Font type (see ::IND_Type).
 * @param pQuality					Font quality (see ::IND_Quality).
 */
bool IND_FontManager::addMudFont(IND_Font		*pNewFont,
                                 IND_Image		*pImage,
                                 const char     *pFile,
                                 IND_Type		pType,
                                 IND_Quality	pQuality) {
	g_debug->header("Parsing and loading MudFont font", DebugApi::LogHeaderBegin);
	g_debug->header("File name:", DebugApi::LogHeaderInfo);
	g_debug->dataChar(pFile, 1);

	if (!_ok) {
		writeMessage();
		return 0;
	}

	// ----- Width and height of the bitmap font MUST be power of two -----

	IND_Math mMath;

	if (!mMath.isPowerOfTwo(pImage->getWidth()) ||
	        !mMath.isPowerOfTwo(pImage->getHeight())) {
		g_debug->header("This operation can not be done", DebugApi::LogHeaderInfo);
		g_debug->dataChar("", 1);
		g_debug->header("The height and width of the MudFont font must be power of 2", DebugApi::LogHeaderError);
		return 0;
	}
    
    // ----- XML font parsing -----
    
	if (!parseMudFont(pNewFont, pFile)) {
		g_debug->header("Fatal error, cannot load the MudFont font xml file", DebugApi::LogHeaderError);
		return 0;
	}
    
	pNewFont->setFileName(pFile);

	// ----- Bitmap (IND_Surface object) creation -----

	IND_Surface *mNewSurface = IND_Surface::newSurface();
	if (!_surfaceManager->add(mNewSurface, pImage, pType, pQuality))
		return 0;

	// IND_Surface object MUST have one block ONLY
	if (mNewSurface->getNumBlocks() > 1) {
		_surfaceManager->remove(mNewSurface);
		return 0;
	}

	pNewFont->setSurface(mNewSurface);

	// ----- Puts the object into the manager -----

	addToList(pNewFont);

	// ----- g_debug -----

	g_debug->header("MudFont font parsed and loaded", DebugApi::LogHeaderEnd);

	return 1;
}

/**
 * Returns 1 (true) if the font object passed as a parameter
 * exists and is added successfully to the manager loading the font directly from
 * a configuration file, generated with an editor that can export the XML AngelCode format
 * @param pNewFont					Pointer to a font.
 * @param pFile                   	Name of the configuration file of the font generated by an editor that exports the AngelCode XML format.
 * @param pType						Font type (see ::IND_Type).
 * @param pQuality					Font quality (see ::IND_Quality).
 */
bool IND_FontManager::addAngelcodeFont(IND_Font     *pNewFont,
                                       const char   *pFile,
                                       IND_Type     pType,
                                       IND_Quality  pQuality) {
	
    
    g_debug->header("Parsing and loading AngelCode font", DebugApi::LogHeaderBegin);
	g_debug->header("File name:", DebugApi::LogHeaderInfo);
	g_debug->dataChar(pFile, 1);
    
	if (!_ok) {
		writeMessage();
		return 0;
	}

    
    
    if(!parseAngelCodeFont(pNewFont,pFile, pType, pQuality))
        return 0;
    
    
    // ----- Puts the object into the manager -----
    
	addToList(pNewFont);
    
    
    // ----- g_debug -----
    
	g_debug->header("AngelCode font parsed and loaded", DebugApi::LogHeaderEnd);
    
	return 1;
}




/**
 * Returns 1 (true) if the font object type 1 passed as a parameter exists
 * and it is deleted from the manager successfully.
 * @param pFo						Pointer to font object type 1
 */
bool IND_FontManager::remove(IND_Font  *pFo) {
	g_debug->header("Freeing font", DebugApi::LogHeaderBegin);

	if (!_ok) {
		writeMessage();
		return 0;
	}

	// Search object
	bool mIs = 0;
	list <IND_Font *>::iterator mFontListIter;
	for (mFontListIter  = _listFonts->begin();
	        mFontListIter != _listFonts->end();
	        mFontListIter++) {
		if ((*mFontListIter) == pFo) {
			mIs = 1;
			break;
		}
	}

	// Not found
	if (!mIs) {
		writeMessage();
		return 0;
	}

	// ----- Free object -----

	g_debug->header("File name:", DebugApi::LogHeaderInfo);
	g_debug->dataChar(pFo->getFileName(), 1);
    
	// Quit from list
	delFromlist(pFo);

	g_debug->header("Ok", DebugApi::LogHeaderEnd);

	return 1;
}

// --------------------------------------------------------------------------------
//									Private methods
// --------------------------------------------------------------------------------

/** @cond DOCUMENT_PRIVATEAPI */

/*
==================
Parses an MudFont
XML font file
Uses Tinyxml
==================
*/
bool IND_FontManager::parseMudFont(IND_Font *pNewFont,const char *pFontName) {
	TiXmlDocument   *mXmlDoc = new TiXmlDocument(pFontName);

	// Fatal error, cannot load
	if (!mXmlDoc->LoadFile()) {
        DISPOSE(mXmlDoc);
     	return 0;
    }
    
    // Setting the type of the font
    pNewFont->setFontType(IND_Font::FONTTYPE_MudFont);

	// Document root
	TiXmlElement *mXFont = 0;
	mXFont = mXmlDoc->FirstChildElement("font");

	if (!mXFont) {
		g_debug->header("Invalid name for document root, should be <font>", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}

	if (mXFont->Attribute("num_characters")) {
		pNewFont->setNumChars(atoi(mXFont->Attribute("num_characters")));
		pNewFont->setLetters(new IND_Font::LETTER [pNewFont->getNumChars()]);
	} else {
		g_debug->header("The font doesn't have a \"num_characters\" attribute", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}

	TiXmlElement *mXChar = 0;
	mXChar = mXFont->FirstChildElement("char");

	if (!mXChar) {
		g_debug->header("There are no chars to parse", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}

	// Parse all the chars
	int mCont = 0;
	while (mXChar) {
		// Id
		if (mXChar->Attribute("id")) {
			pNewFont->getLetters() [mCont]._letter = static_cast<unsigned char>(atoi(mXChar->Attribute("id")));
		} else {
			g_debug->header("The char doesn't have a \"id\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

		// x
		if (mXChar->Attribute("x")) {
			pNewFont->getLetters() [mCont]._x = atoi(mXChar->Attribute("x"));
		} else {
			g_debug->header("The char doesn't have a \"x\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

		// y
		if (mXChar->Attribute("y")) {
			pNewFont->getLetters() [mCont]._y = atoi(mXChar->Attribute("y"));
		} else {
			g_debug->header("The char doesn't have a \"y\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

		// width
		if (mXChar->Attribute("width")) {
			pNewFont->getLetters() [mCont]._width = atoi(mXChar->Attribute("width"));
		} else {
			g_debug->header("The char doesn't have a \"width\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

		// height
		if (mXChar->Attribute("height")) {
			pNewFont->getLetters() [mCont]._height = atoi(mXChar->Attribute("height"));
		} else {
			g_debug->header("The char doesn't have a \"height\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

		// Move to the next char declaration
		mXChar = mXChar->NextSiblingElement("char");

		mCont++;
	}

	mXmlDoc->Clear();
	delete mXmlDoc;

	return 1;
}


/*
 ==================
 Parses an Angelcode
 XML font file
 Uses Tinyxml
 ==================
 */
bool IND_FontManager::parseAngelCodeFont(IND_Font *pNewFont,const char *pFileName, IND_Type pType, IND_Quality pQuality) {
	TiXmlDocument   *mXmlDoc = new TiXmlDocument(pFileName);
    
	// Fatal error, cannot load
	if (!mXmlDoc->LoadFile()) {
        DISPOSE(mXmlDoc);
     	return 0;
    }
    
    // Setting font filename
    pNewFont->setFileName(pFileName);
    
    // Setting the type of the font
    pNewFont->setFontType(IND_Font::FONTTYPE_AngelCode);
    
    
    // Document root
	TiXmlElement *mXFont = 0;
	mXFont = mXmlDoc->FirstChildElement("font");
    
	if (!mXFont) {
		g_debug->header("Invalid name for document root, should be <font>", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
    
    //TODO : info element variables ... maybe
    
    //TODO : common element variables ... maybe
    
    //TODO : pages, this one needs to be done ... MudFont have (allways?) just one page .. Angelcode can have multiple
    
    // Image loading
    
    // Pages element
    TiXmlElement *mXPages = 0;
	mXPages = mXFont->FirstChildElement("pages");
    
    if (!mXPages) {
		g_debug->header("The <font> element doesn't have a <pages> child element", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
    // Page element
	TiXmlElement *mXPage = 0;
	mXPage = mXPages->FirstChildElement("page");
    
	if (!mXPage) {
		g_debug->header("There are no <page> elements to parse", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
	// Parse each page
	int mPageCount = 0;
	while (mXPage) {
        
        // Id
		if (mXPage->Attribute("id")) {
			//pNewFont->getLetters() [mCharCount]._letter = static_cast<unsigned char>(atoi(mXChar->Attribute("id")));  //TODO : FIXME !! id refers to font image, starting from 0 -> 
		} else {
			g_debug->header("The <page> element doesn't have a \"id\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
        // File
        if (mXPage->Attribute("file")) {
            
            IND_Image *mNewImage = IND_Image::newImage();
            bool noImgError = _imageManager->add(mNewImage, mXPage->Attribute("file"));
            if (!noImgError) {
                DISPOSEMANAGED(mNewImage);
                g_debug->header("Failed at adding page image for Angelcode font", DebugApi::LogHeaderError);
                mXmlDoc->Clear();
                delete mXmlDoc;
                return 0;
            }
            
            // ----- Width and height of the bitmap font MUST be power of two -----
            
            IND_Math mMath;
            
            if (!mMath.isPowerOfTwo(mNewImage->getWidth()) ||
                !mMath.isPowerOfTwo(mNewImage->getHeight())) {
                g_debug->header("This operation can not be done", DebugApi::LogHeaderInfo);
                g_debug->dataChar("", 1);
                g_debug->header("The height and width of the AngelCode font font must be power of 2", DebugApi::LogHeaderError);
                mXmlDoc->Clear();
                delete mXmlDoc;
                return 0;
            }
            
            // ----- Bitmap (IND_Surface object) creation -----
            
            IND_Surface *mNewSurface = IND_Surface::newSurface();
            if (!_surfaceManager->add(mNewSurface, mNewImage, pType, pQuality)) {
                mXmlDoc->Clear();
                delete mXmlDoc;
                return 0;
            }   
            
            // IND_Surface object MUST have one block ONLY
            if (mNewSurface->getNumBlocks() > 1) {
                mXmlDoc->Clear();
                delete mXmlDoc;
                _surfaceManager->remove(mNewSurface);
                return 0;
            }
            
            pNewFont->setSurface(mNewSurface); // TODO: somehow handle more than one font surface, - this relates to the "id" attribute parsed..
            
		} else {
			g_debug->header("The <page> element doesn't have a \"file\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
        // Move to the next char declaration
        mXPage = mXPage->NextSiblingElement("page");
        
		mPageCount++;
	
    }
   
   
    // Chars element
    TiXmlElement *mXChars = 0;
	mXChars = mXFont->FirstChildElement("chars");
    
    if (!mXChars) {
		g_debug->header("The <font> element doesn't have a <chars> child element", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
    
    if (mXChars->Attribute("count")) {
		pNewFont->setNumChars(atoi(mXChars->Attribute("count")));
		pNewFont->setLetters(new IND_Font::LETTER [pNewFont->getNumChars()]);
	} else {
		g_debug->header("The <chars> element doesn't have a \"count\" attribute", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
    
    // Char element
	TiXmlElement *mXChar = 0;
	mXChar = mXChars->FirstChildElement("char");
    
	if (!mXChar) {
		g_debug->header("There are no <char> elements to parse", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
	// Parse each char
	int mCharCount = 0;
	while (mXChar) {
		
        // Id
		if (mXChar->Attribute("id")) {
			pNewFont->getLetters() [mCharCount]._letter = static_cast<unsigned char>(atoi(mXChar->Attribute("id")));
		} else {
			g_debug->header("The <char> element doesn't have a \"id\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
		// x
		if (mXChar->Attribute("x")) {
			pNewFont->getLetters() [mCharCount]._x = atoi(mXChar->Attribute("x"));
		} else {
			g_debug->header("The <char> element doesn't have a \"x\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
		// y
		if (mXChar->Attribute("y")) {
			pNewFont->getLetters() [mCharCount]._y = atoi(mXChar->Attribute("y"));
		} else {
			g_debug->header("The <char> element doesn't have a \"y\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
		// width
		if (mXChar->Attribute("width")) {
			pNewFont->getLetters() [mCharCount]._width = atoi(mXChar->Attribute("width"));
		} else {
			g_debug->header("The <char> element doesn't have a \"width\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
		// height
		if (mXChar->Attribute("height")) {
			pNewFont->getLetters() [mCharCount]._height = atoi(mXChar->Attribute("height"));
		} else {
			g_debug->header("The <char> element doesn't have a \"height\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
		// xoffset
		if (mXChar->Attribute("xoffset")) {
			pNewFont->getLetters() [mCharCount]._xOffset = atoi(mXChar->Attribute("xoffset"));
		} else {
			g_debug->header("The char doesn't have a \"xoffset\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

		// yoffset
		if (mXChar->Attribute("yoffset")) {
			pNewFont->getLetters() [mCharCount]._yOffset = atoi(mXChar->Attribute("yoffset"));
		} else {
			g_debug->header("The <char> element doesn't have a \"yoffset\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
        // xadvance
		if (mXChar->Attribute("xadvance")) {
			pNewFont->getLetters() [mCharCount]._xAdvance = atoi(mXChar->Attribute("xadvance"));
		} else {
			g_debug->header("The <char> element doesn't have a \"xadvance\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

        // page
		if (mXChar->Attribute("page")) {
			pNewFont->getLetters() [mCharCount]._page = atoi(mXChar->Attribute("page"));
		} else {
			g_debug->header("The <char> element doesn't have a \"page\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
 
        // chnl
		if (mXChar->Attribute("chnl")) {
			pNewFont->getLetters() [mCharCount]._chnl = atoi(mXChar->Attribute("chnl"));
		} else {
			g_debug->header("The <char> element doesn't have a \"chnl\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}

        
		// Move to the next char declaration
		mXChar = mXChar->NextSiblingElement("char");
        
		mCharCount++;
	}
    
    
    
    
    // Kernings element
    TiXmlElement *mXKernings = 0;
	mXKernings = mXFont->FirstChildElement("kernings");
    
    if (!mXKernings) {
		g_debug->header("The <font> element doesn't have a <kernings> child element", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
    
    if (mXKernings->Attribute("count")) {
        pNewFont->setNumKernings(atoi(mXKernings->Attribute("count")));
		pNewFont->setKernings(new IND_Font::KERNING [pNewFont->getNumKernings()]);
	} else {
		g_debug->header("The <kernings> element doesn't have a \"count\" attribute", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
    
    // Kerning element
	TiXmlElement *mXKerning = 0;
	mXKerning = mXKernings->FirstChildElement("kerning");
    
	if (!mXKerning) {
		g_debug->header("There are no <kerning> elements to parse", DebugApi::LogHeaderError);
		mXmlDoc->Clear();
		delete mXmlDoc;
		return 0;
	}
    
	// Parse each kerning
	int mKerCount = 0;
	while (mXKerning) {
		
        // First
		if (mXKerning->Attribute("first")) {
            pNewFont->getKernings()[mKerCount]._first = atoi(mXKerning->Attribute("first"));
		} else {
			g_debug->header("The <kerning> element doesn't have a \"first\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
        // Second
		if (mXKerning->Attribute("second")) {
			pNewFont->getKernings()[mKerCount]._second = atoi(mXKerning->Attribute("second"));
		} else {
			g_debug->header("The <kerning> element doesn't have a \"second\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
                
        // Amount
		if (mXKerning->Attribute("amount")) {
			pNewFont->getKernings()[mKerCount]._amount = atoi(mXKerning->Attribute("amount"));
		} else {
			g_debug->header("The <kerning> element doesn't have a \"second\" attribute", DebugApi::LogHeaderError);
			mXmlDoc->Clear();
			delete mXmlDoc;
			return 0;
		}
        
        // Move to the next kerning declaration
		mXKerning = mXKerning->NextSiblingElement("kerning");
        
		mKerCount++;
	}


    
    
    
	mXmlDoc->Clear();
	delete mXmlDoc;
    
	return 1;
}



/*
==================
Inserts the font into a list
==================
*/
void IND_FontManager::addToList(IND_Font *pNewFont) {
	_listFonts->push_back(pNewFont);
}

/*
==================
Deletes object from the manager
==================
*/
void IND_FontManager::delFromlist(IND_Font *pFo) {
    // Free bitmap IND_Surface
	_surfaceManager->remove(pFo->getSurface());
	_listFonts->remove(pFo);
	DISPOSEMANAGED(pFo);
}


/*
==================
Initialization error message
==================
*/
void IND_FontManager::writeMessage() {
	g_debug->header("This operation can not be done", DebugApi::LogHeaderInfo);
	g_debug->dataChar("", 1);
	g_debug->header("Invalid Id or FontManager not correctly initialized", DebugApi::LogHeaderError);
}

/*
==================
Init manager vars
==================
*/
void IND_FontManager::initVars() {
	_listFonts = new list <IND_Font *>;
}

/*
==================
Free manager memory
==================
*/
void IND_FontManager::freeVars() {
	// Deletes all the manager entities
	list <IND_Font *>::iterator mFontListIter;
	for (mFontListIter  = _listFonts->begin();
	        mFontListIter != _listFonts->end();
	        mFontListIter++) {
		g_debug->header("Freeing font:", DebugApi::LogHeaderInfo);
		g_debug->dataChar((*mFontListIter)->getFileName(), 1);

		// Free bitmap IND_Surface
		_surfaceManager->remove((*mFontListIter)->getSurface());
        
        // Free font
        DISPOSEMANAGED((*mFontListIter));
	}

	// Clear list
	_listFonts->clear();

	// Free list
	DISPOSE(_listFonts);
}

/** @endcond */
