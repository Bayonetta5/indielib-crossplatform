<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Indielib cross-platform: Bliting Surfaces, Animations, Fonts and setting transformations directly</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Indielib cross-platform
   </div>
   <div id="projectbrief">C++ 2.5d graphics library based in DirectX and OpenGL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___graphical___objects.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Bliting Surfaces, Animations, Fonts and setting transformations directly</div>  </div>
<div class="ingroups"><a class="el" href="group___advances.html">Advances methods for bliting directly to the screen without using entities. It uses IND_Render methods (recommended only for advanced IndieLib users)</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___primitives"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___primitives.html">Bliting Primitives</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___graphical__3d___objects"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical__3d___objects.html">Bliting 3d Animated 3d Models and setting the transformations directly</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga39522360ebed7ee0139187d1570790da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga39522360ebed7ee0139187d1570790da">IND_Render::getNumrenderedObjectsString</a> (char *pBuffer)</td></tr>
<tr class="separator:ga39522360ebed7ee0139187d1570790da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc517bd796574f57c4c87f33bfec791d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gabc517bd796574f57c4c87f33bfec791d">IND_Render::getNumDiscardedObjectsString</a> (char *pBuffer)</td></tr>
<tr class="separator:gabc517bd796574f57c4c87f33bfec791d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2758890a79e93447262a77675203d51c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga2758890a79e93447262a77675203d51c">IND_Render::getNumrenderedObjectsInt</a> ()</td></tr>
<tr class="separator:ga2758890a79e93447262a77675203d51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54278bce7c7da8f5059e28d4cf52c0fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga54278bce7c7da8f5059e28d4cf52c0fc">IND_Render::getNumDiscardedObjectsInt</a> ()</td></tr>
<tr class="separator:ga54278bce7c7da8f5059e28d4cf52c0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695f014c9c4940d974b5ba5010744897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga695f014c9c4940d974b5ba5010744897"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga695f014c9c4940d974b5ba5010744897">IND_Render::resetNumrenderedObject</a> ()</td></tr>
<tr class="memdesc:ga695f014c9c4940d974b5ba5010744897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the counters for rendered objects. <br/></td></tr>
<tr class="separator:ga695f014c9c4940d974b5ba5010744897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c8ad252e06587746a7db93fe71392a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c8ad252e06587746a7db93fe71392a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga1c8ad252e06587746a7db93fe71392a3">IND_Render::resetNumDiscardedObjects</a> ()</td></tr>
<tr class="memdesc:ga1c8ad252e06587746a7db93fe71392a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the counters for discarded objects. <br/></td></tr>
<tr class="separator:ga1c8ad252e06587746a7db93fe71392a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Render settings</h2></td></tr>
<tr class="memitem:ga682758217e4ceb30eb04ac27b92181f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga682758217e4ceb30eb04ac27b92181f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IND_Render::setAntialiasing</b> (bool pSwitch)</td></tr>
<tr class="separator:ga682758217e4ceb30eb04ac27b92181f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8763d2eea657cb37567d306eaf91e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gaf8763d2eea657cb37567d306eaf91e31">IND_Render::showFpsInWindowTitle</a> ()</td></tr>
<tr class="separator:gaf8763d2eea657cb37567d306eaf91e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf9a49bb3fa956697f1b542ad049c0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gaedf9a49bb3fa956697f1b542ad049c0d">IND_Render::setPointPixelScale</a> (float pNewScale)</td></tr>
<tr class="memdesc:gaedf9a49bb3fa956697f1b542ad049c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel to point scaling performed by rendering with vertex and position data.  <a href="#gaedf9a49bb3fa956697f1b542ad049c0d"></a><br/></td></tr>
<tr class="separator:gaedf9a49bb3fa956697f1b542ad049c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Viewport and camera 2d</h2></td></tr>
<tr class="memitem:ga974b11cf130e67ec1166e9903cb6ee1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga974b11cf130e67ec1166e9903cb6ee1e">IND_Render::setViewPort2d</a> (int pX, int pY, int pWidth, int pHeight)</td></tr>
<tr class="separator:ga974b11cf130e67ec1166e9903cb6ee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee43e883cdf664360e4277c3b73960c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gaee43e883cdf664360e4277c3b73960c0">IND_Render::setCamera2d</a> (<a class="el" href="class_i_n_d___camera2d.html">IND_Camera2d</a> *pCamera2d)</td></tr>
<tr class="separator:gaee43e883cdf664360e4277c3b73960c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Viewport and camera 3d</h2></td></tr>
<tr class="memitem:ga287a12952c58833d70825d4170469b2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga287a12952c58833d70825d4170469b2e">IND_Render::setViewPort3d</a> (int pX, int pY, int pWidth, int pHeight)</td></tr>
<tr class="separator:ga287a12952c58833d70825d4170469b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb7d795f3b35fe7eb2dd8c196b246b34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gafb7d795f3b35fe7eb2dd8c196b246b34">IND_Render::setCamera3d</a> (<a class="el" href="class_i_n_d___camera3d.html">IND_Camera3d</a> *pCamera3d)</td></tr>
<tr class="separator:gafb7d795f3b35fe7eb2dd8c196b246b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Advanced transformations methods (it's preferible to use IND_Entity2d and IND_Entity3d instead)</h2></td></tr>
<tr class="memitem:ga516212346723de483ea305893f82e0c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga516212346723de483ea305893f82e0c6">IND_Render::setTransform2d</a> (int pX, int pY, float pAngleX, float pAngleY, float pAngleZ, float pScaleX, float pScaleY, int pAxisCalX, int pAxisCalY, bool pMirrorX, bool pMirrorY, int pWidth, int pHeight, <a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> *pMatrix)</td></tr>
<tr class="separator:ga516212346723de483ea305893f82e0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42fe9fd8e6c7e379bb0262f9140acd52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga42fe9fd8e6c7e379bb0262f9140acd52">IND_Render::setTransform2d</a> (<a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;pTransformMatrix)</td></tr>
<tr class="separator:ga42fe9fd8e6c7e379bb0262f9140acd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec96bb5aee5f8354533488f6e7e3689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga2ec96bb5aee5f8354533488f6e7e3689">IND_Render::setIdentityTransform2d</a> ()</td></tr>
<tr class="separator:ga2ec96bb5aee5f8354533488f6e7e3689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4edbd42c27f22e24b8b0a65e0c350c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga3e4edbd42c27f22e24b8b0a65e0c350c">IND_Render::setRainbow2d</a> (<a class="el" href="group___i_n_d___type.html#gadc8c50be3097db9e80adc393a92a3014">IND_Type</a> pType, bool pCull, bool pMirrorX, bool pMirrorY, <a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420">IND_Filter</a> pFilter, BYTE pR, BYTE pG, BYTE pB, BYTE pA, BYTE pFadeR, BYTE pFadeG, BYTE pFadeB, BYTE pFadeA, <a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a> pSo, <a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a> pDs)</td></tr>
<tr class="separator:ga3e4edbd42c27f22e24b8b0a65e0c350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4886167d26425f28e73e347bbc98e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gade4886167d26425f28e73e347bbc98e3">IND_Render::setTransform3d</a> (float pX, float pY, float pZ, float pAngleX, float pAngleY, float pAngleZ, float pScaleX, float pScaleY, float pScaleZ, <a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> *pMatrix)</td></tr>
<tr class="separator:gade4886167d26425f28e73e347bbc98e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2990d040c36822f52c8aee4eae213c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga2990d040c36822f52c8aee4eae213c5a">IND_Render::setRainbow3d</a> (bool pCull, bool pFlipNormals, <a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420">IND_Filter</a> pFilter, BYTE pR, BYTE pG, BYTE pB, BYTE pA, BYTE pFadeR, BYTE pFadeG, BYTE pFadeB, BYTE pFadeA, <a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a> pSo, <a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a> pDs)</td></tr>
<tr class="separator:ga2990d040c36822f52c8aee4eae213c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e9d909e2fb99491a81e1f4fdc69379"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga72e9d909e2fb99491a81e1f4fdc69379">IND_Render::lookAt</a> (float pEyeX, float pEyeY, float pEyeZ, float pLookAtX, float pLookAtY, float pLookAtZ, float pUpX, float pUpY, float pUpZ)</td></tr>
<tr class="separator:ga72e9d909e2fb99491a81e1f4fdc69379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga246964640f1acd5812ab2773adb1a82c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga246964640f1acd5812ab2773adb1a82c">IND_Render::perspectiveFov</a> (float pFov, float pAspect, float pNearClippingPlane, float pFarClippingPlane)</td></tr>
<tr class="separator:ga246964640f1acd5812ab2773adb1a82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e8a69f0352c0c12ffc9d88f12543b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga70e8a69f0352c0c12ffc9d88f12543b1">IND_Render::perspectiveOrtho</a> (float pWidth, float pHeight, float pNearClippingPlane, float pFarClippingPlane)</td></tr>
<tr class="separator:ga70e8a69f0352c0c12ffc9d88f12543b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Advanced 2d bliting methods (it's preferible to use IND_Entity2d together with IND_Entity2dManager instead)</h2></td></tr>
<tr class="memitem:ga50c9fdcc248a7771f8dd518ac4172203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga50c9fdcc248a7771f8dd518ac4172203">IND_Render::blitText</a> (<a class="el" href="class_i_n_d___font.html">IND_Font</a> *pFo, char *pText, int pX, int pY, int pOffset, int pLineSpacing, float pScaleX, float pScaleY, BYTE pR, BYTE pG, BYTE pB, BYTE pA, BYTE pFadeR, BYTE pFadeG, BYTE pFadeB, BYTE pFadeA, <a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420">IND_Filter</a> pLinearFilter, <a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a> pSo, <a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a> pDs, <a class="el" href="group___i_n_d___align.html#gad7dc778700ecdc3c72b14fd5ffe4919d">IND_Align</a> pAlign)</td></tr>
<tr class="separator:ga50c9fdcc248a7771f8dd518ac4172203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eaa60e59777b96d8e2cc20fc962ffb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga6eaa60e59777b96d8e2cc20fc962ffb5">IND_Render::blitAnimation</a> (<a class="el" href="class_i_n_d___animation.html">IND_Animation</a> *pAn, int pSequence, int pX, int pY, int pWidth, int pHeight, bool pToggleWrap, float pUDisplace, float pVDisplace)</td></tr>
<tr class="separator:ga6eaa60e59777b96d8e2cc20fc962ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c92fec6435b128454b73ef4a835322a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga2c92fec6435b128454b73ef4a835322a">IND_Render::blitSurface</a> (<a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *pSu)</td></tr>
<tr class="separator:ga2c92fec6435b128454b73ef4a835322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653cdf8aae9cc65b1414e6d5e3398082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga653cdf8aae9cc65b1414e6d5e3398082">IND_Render::blitGrid</a> (<a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *pSu, BYTE pR, BYTE pG, BYTE pB, BYTE pA)</td></tr>
<tr class="separator:ga653cdf8aae9cc65b1414e6d5e3398082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091d11494c0b40474a5cb7d6f5caf785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga091d11494c0b40474a5cb7d6f5caf785">IND_Render::blitRegionSurface</a> (<a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *pSu, int pX, int pY, int pWidth, int pHeight)</td></tr>
<tr class="separator:ga091d11494c0b40474a5cb7d6f5caf785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d62c38b5f68539a73320794d90c600"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga54d62c38b5f68539a73320794d90c600">IND_Render::blitWrapSurface</a> (<a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *pSu, int pWidth, int pHeight, float pUDisplace, float pVDisplace)</td></tr>
<tr class="separator:ga54d62c38b5f68539a73320794d90c600"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Gets</h2></td></tr>
<tr class="memitem:gaccfdad6284311cbf272421d9170f8816"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaccfdad6284311cbf272421d9170f8816"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gaccfdad6284311cbf272421d9170f8816">IND_Render::getViewPortX</a> ()</td></tr>
<tr class="memdesc:gaccfdad6284311cbf272421d9170f8816"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the x position of the actual viewport. <br/></td></tr>
<tr class="separator:gaccfdad6284311cbf272421d9170f8816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f99b1e10333edbf2c172195a710eff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78f99b1e10333edbf2c172195a710eff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga78f99b1e10333edbf2c172195a710eff">IND_Render::getViewPortY</a> ()</td></tr>
<tr class="memdesc:ga78f99b1e10333edbf2c172195a710eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the y position of the actual viewport. <br/></td></tr>
<tr class="separator:ga78f99b1e10333edbf2c172195a710eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbca8f98844022ec5d79c32798b68bf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadbca8f98844022ec5d79c32798b68bf6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gadbca8f98844022ec5d79c32798b68bf6">IND_Render::getViewPortWidth</a> ()</td></tr>
<tr class="memdesc:gadbca8f98844022ec5d79c32798b68bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the width position of the actual viewport. <br/></td></tr>
<tr class="separator:gadbca8f98844022ec5d79c32798b68bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf96d8f11c84978cfd5033094e556ffdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf96d8f11c84978cfd5033094e556ffdd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gaf96d8f11c84978cfd5033094e556ffdd">IND_Render::getViewPortHeight</a> ()</td></tr>
<tr class="memdesc:gaf96d8f11c84978cfd5033094e556ffdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the width position of the actual viewport. <br/></td></tr>
<tr class="separator:gaf96d8f11c84978cfd5033094e556ffdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab794c2e20038b5f1f10a3d7d50e5c3be"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gab794c2e20038b5f1f10a3d7d50e5c3be">IND_Render::getVersion</a> ()</td></tr>
<tr class="memdesc:gab794c2e20038b5f1f10a3d7d50e5c3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the actual version of Direct3d that is using <a class="el" href="class_indie_lib.html">IndieLib</a>.  <a href="#gab794c2e20038b5f1f10a3d7d50e5c3be"></a><br/></td></tr>
<tr class="separator:gab794c2e20038b5f1f10a3d7d50e5c3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767983c60ccf433884c7597f8f25876d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga767983c60ccf433884c7597f8f25876d"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga767983c60ccf433884c7597f8f25876d">IND_Render::getVendor</a> ()</td></tr>
<tr class="memdesc:ga767983c60ccf433884c7597f8f25876d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the name of the graphic card vendor. <br/></td></tr>
<tr class="separator:ga767983c60ccf433884c7597f8f25876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643f2a062e7d6e6115eaf263b2180dd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga643f2a062e7d6e6115eaf263b2180dd0"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga643f2a062e7d6e6115eaf263b2180dd0">IND_Render::getRenderer</a> ()</td></tr>
<tr class="memdesc:ga643f2a062e7d6e6115eaf263b2180dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the name of the graphic card. <br/></td></tr>
<tr class="separator:ga643f2a062e7d6e6115eaf263b2180dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafada339c64a4b9355fb0f7c028acdfd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafada339c64a4b9355fb0f7c028acdfd1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#gafada339c64a4b9355fb0f7c028acdfd1">IND_Render::getMaxTextureSize</a> ()</td></tr>
<tr class="memdesc:gafada339c64a4b9355fb0f7c028acdfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the maximum texture size allowed by the graphic card. <br/></td></tr>
<tr class="separator:gafada339c64a4b9355fb0f7c028acdfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119d9e65701018180070cb9a6df5d21f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga119d9e65701018180070cb9a6df5d21f">IND_Render::getFpsString</a> (char *pBuffer)</td></tr>
<tr class="separator:ga119d9e65701018180070cb9a6df5d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1732bd53b3d0b6f51cce4a9f7be7eca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1732bd53b3d0b6f51cce4a9f7be7eca2"></a>
<a class="el" href="class_i_n_d___window.html">IND_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga1732bd53b3d0b6f51cce4a9f7be7eca2">IND_Render::getWindow</a> ()</td></tr>
<tr class="memdesc:ga1732bd53b3d0b6f51cce4a9f7be7eca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a pointer to the <a class="el" href="class_i_n_d___window.html">IND_Window</a> object where the render has been created. <br/></td></tr>
<tr class="separator:ga1732bd53b3d0b6f51cce4a9f7be7eca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216b992b23ee70382f8fbb8b28831ddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga216b992b23ee70382f8fbb8b28831ddc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga216b992b23ee70382f8fbb8b28831ddc">IND_Render::getFpsInt</a> ()</td></tr>
<tr class="memdesc:ga216b992b23ee70382f8fbb8b28831ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the actual fps (frames per second) in an int. <br/></td></tr>
<tr class="separator:ga216b992b23ee70382f8fbb8b28831ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e7b4bc57ca0a8f7c0112bda201d648e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___graphical___objects.html#ga9e7b4bc57ca0a8f7c0112bda201d648e">IND_Render::getFrameTime</a> ()</td></tr>
<tr class="memdesc:ga9e7b4bc57ca0a8f7c0112bda201d648e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns in miliseconds the time that took the previous frame.  <a href="#ga9e7b4bc57ca0a8f7c0112bda201d648e"></a><br/></td></tr>
<tr class="separator:ga9e7b4bc57ca0a8f7c0112bda201d648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>With these methods you can set the 2d transformations (using IND_Render::Set2dTransform) and color attributes (using IND_Render::SetRainbow()) and blit directly to the screen surfaces, animations, and fonts using <a class="el" href="class_i_n_d___render.html">IND_Render</a> class.</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> together with <a class="el" href="class_i_n_d___entity2d_manager.html">IND_Entity2dManager</a> for drawing these graphical objects to the screen without having to use this advanced method directly. This method is only useful for advanced users for really concrete purposes. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6eaa60e59777b96d8e2cc20fc962ffb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IND_Render::blitAnimation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___animation.html">IND_Animation</a> *&#160;</td>
          <td class="paramname"><em>pAn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pToggleWrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pUDisplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pVDisplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pAn</b> Pointer to a <a class="el" href="class_i_n_d___animation.html">IND_Animation</a> object </li>
<li><b>pSequence</b> Number of the sequence to blit (the first sequence is 0) </li>
<li><b>pX</b>, <b>pY</b> Upper left coordinate of the region </li>
<li><b>pWidth</b>, <b>pHeight</b> Width and Height of the region </li>
<li><b>pToggleWrap</b> Wraping on (1) / off (0) </li>
<li><b>pUDisplace</b>, <b>pVDisplace</b> Horizontal and vertical displacement of the image</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function blits directly to the screen a certain sequence of a <a class="el" href="class_i_n_d___animation.html">IND_Animation</a> object.</p>
<p>Each frame of the animation will be blited to the screen the number of milliseconds that are defined in the animation script file. The sequecen starts in the frame 0 and finishes in the last frame specefied in the animation script. The animation will be displayed only one time, after that it will stop in the last frame (bliting it permanently).</p>
<p>This functions returns -1 when the animation finishes, 0 if there is any error (for example trying to blit an invalid <a class="el" href="class_i_n_d___animation.html">IND_Animation</a> pointer) and 1 if is in the middle of the animation and there are no errors.</p>
<p>In order to change the transformations and color attributes of the animation you have to use the DirectXRender::setTransform2d() and DirectXRender::setRainbow2d() methods before calling to this function. Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for drawing animations to the screen without having to use this advanced methods directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Special remark: if you specify a region this function only works with <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> objects that only have ONE texture assigned (you can check this using::IND_Surface::getNumTextures() method). So, it will work only with images that are power of two and lower than the maximum texture size allowed by your card (you can check this parameter using ::DirectXRender::getMaxTextureSize()). The method will return 0 otherwise.</p>
<p>Using this method is equivalent to using all of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#aef59718436b8814bbe436896881981a4">IND_Entity2d::setAnimation()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a2132c2148e1c4104160c6ac1c3368fa0">IND_Entity2d::setRegion()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1424e885e0fe91b8a22a1df8aa88f388">IND_Entity2d::toggleWrap()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#ac77a9628f8af05191832f8b6a9d3d0d9">IND_Entity2d::setWrapDisplacement()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga653cdf8aae9cc65b1414e6d5e3398082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::blitGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *&#160;</td>
          <td class="paramname"><em>pSu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pSu</b> Pointer to a <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> object</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function blits directly to the screen the grid of an <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> object.</p>
<p>Using this method is equivalent to using both of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d_manager.html#a814a01ddd5c333ae2b37b123209ee0cc">IND_Entity2dManager::renderGridAreas()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#aa14a9301cbd1441bce8d994b819c8277">IND_Entity2d::showGridAreas()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga091d11494c0b40474a5cb7d6f5caf785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::blitRegionSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *&#160;</td>
          <td class="paramname"><em>pSu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pSu</b> Pointer to a <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> object </li>
<li><b>pX</b>, <b>pY</b> Upper left coordinate of the region </li>
<li><b>pWidth</b>, <b>pHeight</b> Width and Height of the region</li>
</ul>
<p><b>Operation:</b> </p>
<p>This method is useful when we want to render only a certain region of a <a class="el" href="class_i_n_d___surface.html">IND_Surface</a>.</p>
<p>If the region that we chose is out of the range of the sprite, the function will return false and no region will be rendered.</p>
<p>Special remark: this function only works with <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> objects that only have ONE texture assigned (you can check this using::IND_Surface::getNumTextures() method). So, it will work only with images that are power of two and lower than the maximum texture size allowed by your card (you can check this parameter using ::DirectXRender::getMaxTextureSize()). The method will return 0 otherwise.</p>
<p>In order to change the transformations and color attributes of the surface you have to use the DirectXRender::setTransform2d() and DirectXRender::setRainbow2d() methods before calling to this function. Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for drawing surfaces to the screen without having to use this advanced methods directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Using this method is equivalent to using both of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#a1ab0eff38c9b443a753af7127ec07468">IND_Entity2d::setSurface()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a2132c2148e1c4104160c6ac1c3368fa0">IND_Entity2d::setRegion()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2c92fec6435b128454b73ef4a835322a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::blitSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *&#160;</td>
          <td class="paramname"><em>pSu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pSu</b> Pointer to a <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> object</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function blits directly to the screen a <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> object.</p>
<p>In order to change the transformations and color attributes of the surface you have to use the DirectXRender::setTransform2d() and DirectXRender::setRainbow2d() methods before calling this function. Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for drawing surfaces to the screen without having to use these advanced methods directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Using this method is equivalent to using:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#a1ab0eff38c9b443a753af7127ec07468">IND_Entity2d::setSurface()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga50c9fdcc248a7771f8dd518ac4172203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::blitText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___font.html">IND_Font</a> *&#160;</td>
          <td class="paramname"><em>pFo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pLineSpacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420">IND_Filter</a>&#160;</td>
          <td class="paramname"><em>pLinearFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a>&#160;</td>
          <td class="paramname"><em>pSo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a>&#160;</td>
          <td class="paramname"><em>pDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___align.html#gad7dc778700ecdc3c72b14fd5ffe4919d">IND_Align</a>&#160;</td>
          <td class="paramname"><em>pAlign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pFo</b> Pointer to a <a class="el" href="class_i_n_d___font.html">IND_Font</a> object </li>
<li><b>pText</b> Text to write to the screen </li>
<li><b>pX</b>, <b>pY</b> Position </li>
<li><b>pOffset</b> Char spacing </li>
<li><b>pLineSpacing</b> Line spacing </li>
<li><b>pR</b>, <b>pG</b>, <b>pB</b> R, G, B components of the tinting color </li>
<li><b>pA</b> Transparency level. (255 = complety opaque) </li>
<li><b>pFadeR</b>, <b>pFadeG</b>, <b>pFadeB</b>, <b>pFadeA</b> Fade to a color. </li>
<li><b>pFilter</b> <a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420" title="Texture filters.">IND_Filter</a> type </li>
<li><b>pSo</b> Source blending, see (<a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c" title="Blending type.">IND_BlendingType</a>). </li>
<li><b>pDs</b> Destiny blending, see (<a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c" title="Blending type.">IND_BlendingType</a>). </li>
<li><b>pAlign</b> Text alignment, see::IND_Align.</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function blits text directly to the screen using the <a class="el" href="class_i_n_d___font.html">IND_Font</a> object.</p>
<p>Important: you cannot change the transformation or color attributes of a font using DirectXRender::setTransform2d() or DirectXRender::SetRainbow().</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for drawing fonts to the screen without having to use this advanced method directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Using this method is equivalent to using a combination of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#ae30979e23720efc0dd55dd5d4e3c86c5">IND_Entity2d::setFont()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a262307147825572fcdaf3325929e4b1d">IND_Entity2d::setPosition()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a751b713e000c72be384c6197ee436777">IND_Entity2d::setText()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a2845d1925333bbb1f0a504a254a22469">IND_Entity2d::setCharSpacing()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#abb9a6062c0b4be0791e510e68e9304fd">IND_Entity2d::setLineSpacing()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a941d8ac43272d70ec359233e8689e6b1">IND_Entity2d::setAlign()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga54d62c38b5f68539a73320794d90c600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Render::blitWrapSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___surface.html">IND_Surface</a> *&#160;</td>
          <td class="paramname"><em>pSu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pUDisplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pVDisplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pSu</b> Pointer to a <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> object </li>
<li><b>pX</b>, <b>pY</b> Upper left coordinate of the region </li>
<li><b>pWidth</b>, <b>pHeight</b> Width and Height of the region </li>
<li><b>pUDisplace</b>, <b>pVDisplace</b> Horizontal and vertical displacement of the image</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function returns 1 (true) if it blits directly to the screen a <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> object tiling it both in X and Y coordinates.</p>
<p>This method is useful when we want to render a tiled texture or background.</p>
<p>Special remark: this function only works with <a class="el" href="class_i_n_d___surface.html">IND_Surface</a> objects that only have ONE texture assigned (you can check this using::IND_Surface::getNumTextures() method). So, it will work only with images that are power of two and lower than the maximum texture size allowed by your card (you can check this parameter using ::DirectXRender::getMaxTextureSize()). The method will return 0 otherwise.</p>
<p>In order to change the transformations and color attributes of the surface you have to use the DirectXRender::setTransform2d() and DirectXRender::setRainbow2d() methods before calling to this function. Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for drawing surfaces to the screen without having to use this advanced methods directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Using this method is equivalent to using all of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#a1ab0eff38c9b443a753af7127ec07468">IND_Entity2d::setSurface()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a2132c2148e1c4104160c6ac1c3368fa0">IND_Entity2d::setRegion()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1424e885e0fe91b8a22a1df8aa88f388">IND_Entity2d::toggleWrap()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#ac77a9628f8af05191832f8b6a9d3d0d9">IND_Entity2d::setWrapDisplacement()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga119d9e65701018180070cb9a6df5d21f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::getFpsString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the actual fps (frames per second) in a string of chars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_String</td><td>IN-OUT buffer capable to hold string representation of integer FPS value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e7b4bc57ca0a8f7c0112bda201d648e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float IND_Render::getFrameTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns in miliseconds the time that took the previous frame. </p>
<p>It is very useful to indicate transformations along the timeline.</p>
<p>For example, making Position_X += Speed * Render.getFrameTime() / 1000.0f we would get one x position that would go moving along the time with a given speed. </p>

</div>
</div>
<a class="anchor" id="ga54278bce7c7da8f5059e28d4cf52c0fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IND_Render::getNumDiscardedObjectsInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of discarded objects in one frame (integer) </p>
<dl class="section return"><dt>Returns</dt><dd>The number of objects </dd></dl>

</div>
</div>
<a class="anchor" id="gabc517bd796574f57c4c87f33bfec791d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::getNumDiscardedObjectsString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of discarded objects in one frame </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_String</td><td>IN-OUT buffer capable to hold string representation of integer. Recommended size is 15 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2758890a79e93447262a77675203d51c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IND_Render::getNumrenderedObjectsInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of renderered objects in one frame (integer) </p>
<dl class="section return"><dt>Returns</dt><dd>The number of objects </dd></dl>

</div>
</div>
<a class="anchor" id="ga39522360ebed7ee0139187d1570790da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::getNumrenderedObjectsString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of renderered objects in one frame </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_String</td><td>IN-OUT buffer capable to hold string representation of integer. Recommended size is 15 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab794c2e20038b5f1f10a3d7d50e5c3be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * IND_Render::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the actual version of Direct3d that is using <a class="el" href="class_indie_lib.html">IndieLib</a>. </p>
<p>This function returns the actual version of Direct3d that is using IndiGeLib. </p>

</div>
</div>
<a class="anchor" id="ga72e9d909e2fb99491a81e1f4fdc69379"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::lookAt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pEyeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pEyeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pEyeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pLookAtX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pLookAtY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pLookAtZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pUpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pUpY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pUpZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pEyeX</b>, pEyeY, pEyeZ Position of the camera </li>
<li><b>pLookAtX</b>, pLookAtY, pLookAtZ Vector defining the direction of the camera </li>
<li><b>pUpX</b>, pUpY, pUpZ Vector "up" of the camera.</li>
</ul>
<p>Operation:</p>
<p>This function sets a perspective matrix through the definition of a position and two vectors (lookat and up).</p>
<p>Using this method is equivalent to using a combination of methods of the class ::setCamera3d(). </p>

</div>
</div>
<a class="anchor" id="ga246964640f1acd5812ab2773adb1a82c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::perspectiveFov </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pFov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pAspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pNearClippingPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pFarClippingPlane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pFov</b> Vertical fov </li>
<li><b>pAspect</b> Aspect ratio (usually the width of the viewport divided by the height) </li>
<li><b>pNearClippingPlane</b> Near clipping plane </li>
<li><b>pFarClippingPlane</b> Far clipping plane</li>
</ul>
<p>Operation:</p>
<p>This function sets a fov projection matrix.</p>
<p>This method is equivalent to use a combination of methods of the class ::setCamera3d(). </p>

</div>
</div>
<a class="anchor" id="ga70e8a69f0352c0c12ffc9d88f12543b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::perspectiveOrtho </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pNearClippingPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pFarClippingPlane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pWidth</b> Width </li>
<li><b>pHeight</b> Height </li>
<li><b>pNearClippingPlane</b> Near clipping plane </li>
<li><b>pFarClippingPlane</b> Far clipping plane</li>
</ul>
<p>Operation:</p>
<p>This function sets a orthographic projection matrix.</p>
<p>Using this method is equivalent to using a combination of the methods of the class ::setCamera3d(). </p>

</div>
</div>
<a class="anchor" id="gaee43e883cdf664360e4277c3b73960c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setCamera2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___camera2d.html">IND_Camera2d</a> *&#160;</td>
          <td class="paramname"><em>pCamera2d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pCamera2d</b> <a class="el" href="class_i_n_d___camera2d.html">IND_Camera2d</a> object that defines a camera.</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function sets a 2d camera. See the methods of <a class="el" href="class_i_n_d___camera2d.html">IND_Camera2d</a> for information on how you can manipulate the camera. </p>

</div>
</div>
<a class="anchor" id="gafb7d795f3b35fe7eb2dd8c196b246b34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setCamera3d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___camera3d.html">IND_Camera3d</a> *&#160;</td>
          <td class="paramname"><em>pCamera3d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pCamera3d</b> <a class="el" href="class_i_n_d___camera3d.html">IND_Camera3d</a> object that defines a camera.</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function sets a 3d camera. See the methods of <a class="el" href="class_i_n_d___camera3d.html">IND_Camera3d</a> for information on how you can manipulate the camera. </p>

</div>
</div>
<a class="anchor" id="ga2ec96bb5aee5f8354533488f6e7e3689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setIdentityTransform2d </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Operation:</b> </p>
<p>This function sets the 2d transformation to identity. That is no transformation.</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for applying 2d transformations to the graphical objects without having to use this advanced method directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Using this method is equivalent to using a combination of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#aef59718436b8814bbe436896881981a4">IND_Entity2d::setAnimation()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1ab0eff38c9b443a753af7127ec07468">IND_Entity2d::setSurface()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#af13ad8c40136fbe861675d979a59af78">IND_Entity2d::setPrimitive2d()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#ae30979e23720efc0dd55dd5d4e3c86c5">IND_Entity2d::setFont()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a262307147825572fcdaf3325929e4b1d">IND_Entity2d::setPosition()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#acdf17679ee28eea4072e53b4f588ca15">IND_Entity2d::setAngleXYZ()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#af98e3c6e7b068566bd88f97616b4b44c">IND_Entity2d::setScale()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a9955b77af097d21ccf7612b970a3e86d">IND_Entity2d::setBackCull()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a4159b55c2684982f9495b06ce8c42504">IND_Entity2d::setMirrorX()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a5ca7171310a4637e716b4c129695bc17">IND_Entity2d::setMirrorY()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a3a85d26de9dc9e4083507d7660362eae">IND_Entity2d::setFilter()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a7cbf96ce94827ef15a95c8e3a159094a">IND_Entity2d::setHotSpot()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a2132c2148e1c4104160c6ac1c3368fa0">IND_Entity2d::setRegion()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1424e885e0fe91b8a22a1df8aa88f388">IND_Entity2d::toggleWrap()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="gaedf9a49bb3fa956697f1b542ad049c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setPointPixelScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pNewScale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pixel to point scaling performed by rendering with vertex and position data. </p>
<p>Default value is 1.0f. Takes effect after the next setCamera2d call.</p>
<p>By default pixel-to-point scaling is 1, so position of objects and vertex coordinates submitted to the renderer are 1 to 1 related to pixels in the backed framebuffer screen. You can change that if you want to maintain same 'logical' coordinates of your objects in your scene, independent of the device resolution that you actually render on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNewScale</td><td>Non-negative, non-zero value to apply scale globally. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e4edbd42c27f22e24b8b0a65e0c350c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setRainbow2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_n_d___type.html#gadc8c50be3097db9e80adc393a92a3014">IND_Type</a>&#160;</td>
          <td class="paramname"><em>pType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pCull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pMirrorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pMirrorY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420">IND_Filter</a>&#160;</td>
          <td class="paramname"><em>pFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a>&#160;</td>
          <td class="paramname"><em>pSo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a>&#160;</td>
          <td class="paramname"><em>pDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pType</b> <a class="el" href="group___i_n_d___type.html#gadc8c50be3097db9e80adc393a92a3014" title="Surface types.">IND_Type</a> type of the following graphical object. </li>
<li><b>pCull</b> Backface culling. (true / false) = (on / off). This feature can be deactivated when we are going to rotate the graphical object in the x or y coordinates. This way it is possible to draw for example the leaf of a tree that falls down rotating and shows both faces. In cases that you don't want to draw back faces deactivate this for faster render times. </li>
<li><b>pMirrorX</b> Horizontal mirroring. (true / false) = (activated / deactivated). </li>
<li><b>pMirrorY</b> Vertical mirroring. (true / false) = (activated / deactivated). </li>
<li><b>pFilter</b> Type of filter <a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420" title="Texture filters.">IND_Filter</a>. There are two types of filters that can be applied to the graphical object when it suffers a rotation or scaling:<ul>
<li><a class="el" href="group___i_n_d___filter.html#gac91de5321e12b1dd94bf89fd9d990f49" title="Nearest point filter. This is faster than IND_FILTER_LINEAR, but has less quality.">IND_FILTER_POINT</a> (Nearest point filter). Less quality, but bigger performance. It is possible to use this one without quality loss in graphical objects that don't rotate or are affected by scaling.</li>
<li><a class="el" href="group___i_n_d___filter.html#gadab1049abf297b6f2d79f4b0f7a1986e" title="Bilinear interpolation filter. This is quite fast, and has better quality than IND_FILTER_POINT.">IND_FILTER_LINEAR</a> (Bilinear filter). More quality, but less performance. Used in graphical objects that be rotated or affected by scaling. </li>
</ul>
</li>
<li><b>pR</b>, pG, pB Color BYTEs FadeR, FadeG, FadeB Used for fading the image to a certain color. For example, if we use RGB = (255, 0, 0), the image will progressively become red. </li>
<li><b>pA</b> The A BYTE indicates the level of transparency. If a value of 0 is used, the following graphical object will be completely transparent, as opposed to the value 255 that will cause the object to be drawn completely opaque. It is possible to use all the intermediate values for different levels of transparency. </li>
<li><b>pFadeR</b>, <b>pFadeG</b>, <b>pFadeB</b>, <b>pFadeA</b> Bytes FadeR, FadeG, FadeB Used for fading the image to a certain color. For example, if we use RGB = (255, 0, 0), the image will progressively become red. </li>
<li><b>pSo</b> Indicates the blending source, see (<a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c" title="Blending type.">IND_BlendingType</a>). </li>
<li><b>pDs</b> Indicates the blending destiny, see (<a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c" title="Blending type.">IND_BlendingType</a>).</li>
</ul>
<p>Operation:</p>
<p>This functions sets the color and blending attributes of a graphical object. It should be used before any calling to the Blit methods.</p>
<p>Important: It is not possible to use tinting and fading at the same time, the fading will overide the tinting.</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> objects for applying color transformations to the graphical objects without having to use this advanced method directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Using this method is equivalent to using a combination of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#a15c7a38cea5dad894fb997ccdf14e747">IND_Entity2d::setTransparency()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#ac8b7d4a077dcb3b1630494bcc28bb061">IND_Entity2d::setFade()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a029f8c6bc02a5482e7e5ab02461786c2">IND_Entity2d::setTint()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a5da26b8a8ed587bea58abaf1d640c086">IND_Entity2d::setBlendSource()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a24ae37984ae340f0205818853c9cb8f5">IND_Entity2d::setBlendDest()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga2990d040c36822f52c8aee4eae213c5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setRainbow3d </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pCull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pFlipNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420">IND_Filter</a>&#160;</td>
          <td class="paramname"><em>pFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>pFadeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a>&#160;</td>
          <td class="paramname"><em>pSo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c">IND_BlendingType</a>&#160;</td>
          <td class="paramname"><em>pDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pCull</b> Backface culling. (true / false) = (on / off). This parameter can be deactivated when we are going to go inside a 3dMesh and we want to render both faces of the polygons.In any other case this parameter must be activated for faster rendering times preventing the hardware from drawing back faces. </li>
<li><b>pFilter</b> Type of filter <a class="el" href="group___i_n_d___filter.html#ga6693382ff655f59c9c94aea5e4bd2420" title="Texture filters.">IND_Filter</a>. There are two types of filters that can be applied to the graphical object when it suffers a rotation or scaling:<ul>
<li><a class="el" href="group___i_n_d___filter.html#gac91de5321e12b1dd94bf89fd9d990f49" title="Nearest point filter. This is faster than IND_FILTER_LINEAR, but has less quality.">IND_FILTER_POINT</a> (Nearest point filter). Less quality, but bigger performance. It is possible to use this one without quality loss in graphical objects that don't rotate or are affected by scaling.</li>
<li><a class="el" href="group___i_n_d___filter.html#gadab1049abf297b6f2d79f4b0f7a1986e" title="Bilinear interpolation filter. This is quite fast, and has better quality than IND_FILTER_POINT.">IND_FILTER_LINEAR</a> (Bilinear filter). More quality, but less performance. Used in graphical objects that be rotated or affected by scaling. </li>
</ul>
</li>
<li><b>pR</b>, pG, pB Color bytes FadeR, FadeG, FadeB Used for fading the image to a certain color. For example, if we use RGB = (255, 0, 0), the image will progressively become red. </li>
<li><b>pA</b> The A byte indicates the level of transparency. If a value of 0 is used, the following graphical object will be completely transparent, as opposed to the value 255 that will cause the object to be drawn completely opaque. It is possible to use all the intermediate values for different levels of transparency. </li>
<li><b>pFadeR</b>, <b>pFadeG</b>, <b>pFadeB</b>, <b>pFadeA</b> Bytes FadeR, FadeG, FadeB Used for fading the image to a certain color. For example, if we use RGB = (255, 0, 0), the image will progressively become red. </li>
<li><b>pSo</b> Indicates the blending source, see (<a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c" title="Blending type.">IND_BlendingType</a>). </li>
<li><b>pDs</b> Indicates the blending destiny, see (<a class="el" href="group___i_n_d___blending_type.html#ga0c6c208f915bd65b3c330e683e00079c" title="Blending type.">IND_BlendingType</a>).</li>
</ul>
<p>Operation:</p>
<p>This functions sets the color and blending attributes of the following graphical object. It should be used before any calling to the Blit methods.</p>
<p>Important: It is not possible to use tinting and fading at the same time, the fading will overide the tinting.</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> objects for applying color transformations to the graphical objects without having to use this advanced method directly. This method is only useful for advanced users for really concrete purposes.</p>
<p>Using this method is equivalent to using a combination of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#a15c7a38cea5dad894fb997ccdf14e747">IND_Entity2d::setTransparency()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#ac8b7d4a077dcb3b1630494bcc28bb061">IND_Entity2d::setFade()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a029f8c6bc02a5482e7e5ab02461786c2">IND_Entity2d::setTint()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a5da26b8a8ed587bea58abaf1d640c086">IND_Entity2d::setBlendSource()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a24ae37984ae340f0205818853c9cb8f5">IND_Entity2d::setBlendDest()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga516212346723de483ea305893f82e0c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setTransform2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pAngleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pAngleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pAngleZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pAxisCalX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pAxisCalY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pMirrorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pMirrorY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> *&#160;</td>
          <td class="paramname"><em>pMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pX</b> Translation in the X coordinate. The (0, 0) position is the upper-left corner of the Viewport </li>
<li><b>pY</b> Translation in the Y coordinate. The (0, 0) position is the upper-left corner of the Viewport </li>
<li><b>pAngleX</b> Rotation in the angle x in degrees </li>
<li><b>pAngleY</b> Rotation in the angle y in degrees </li>
<li><b>pAngleZ</b> Rotation in the angle z in degrees </li>
<li><b>pScaleX</b> Scaling in the x coordinate. 1 for maintaining the original size </li>
<li><b>pScaleY</b> Scaling in the y coordinate. 1 for maintaining the original size </li>
<li><b>pAxisCalX</b>, <b>pAxisCalY</b> Parameters that indicates the displacement that the graphical object undergoes due to the HotSpot. If the HotSpot is not specified, the value should be 0 for both of them. All the transformation will be aplied from the upper-left corner of the object. </li>
<li><b>pMirrorX</b> Horizontal mirroring. (true / false) = (activated / deactivated). </li>
<li><b>pMirrorY</b> Vertical mirroring. (true / false) = (activated / deactivated). </li>
<li><b>pWidth</b> Width of the graphical object that we are going to blit just after applying the transformation. You shoud use the getWidth() method of the object. </li>
<li><b>pHeight</b> Height of the graphical object that we are going to blit just after applying the transformation. You shoud use the getHeight() method on the object. </li>
<li><b>pMatrix</b> Pointer to a <a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f" title="Matrix 4x4  (_11, _21, _31, _41,  _12, _22, _32, _42,  _13, _23, _33, _43  _14, _24, _34, _44)">IND_Matrix</a> matrix. In this parameter will be returned by reference the world matrix transformation that will be aplied to the graphical object. This matrix can be useful for advanced programmers that need the algebraic description of the transformation. It is possible to use the value 0 if it not necessary to have this matrix information. <b>Operation:</b> </li>
</ul>
<p>This function sets the 2d transformation (translation, rotation, scaling, mirroring and hotspot) of the following 2d graphical objects that will be rendered by the engine. You should use this method before calling to any of the Bliting methods.</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for applying 2d transformations to the graphical objects without having to use this advanced method directly. This method is only useful for advanced users with really concrete purposes.</p>
<p>Using this method is equivalent to using a combination of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#aef59718436b8814bbe436896881981a4">IND_Entity2d::setAnimation()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1ab0eff38c9b443a753af7127ec07468">IND_Entity2d::setSurface()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#af13ad8c40136fbe861675d979a59af78">IND_Entity2d::setPrimitive2d()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#ae30979e23720efc0dd55dd5d4e3c86c5">IND_Entity2d::setFont()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a262307147825572fcdaf3325929e4b1d">IND_Entity2d::setPosition()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#acdf17679ee28eea4072e53b4f588ca15">IND_Entity2d::setAngleXYZ()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#af98e3c6e7b068566bd88f97616b4b44c">IND_Entity2d::setScale()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a9955b77af097d21ccf7612b970a3e86d">IND_Entity2d::setBackCull()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a4159b55c2684982f9495b06ce8c42504">IND_Entity2d::setMirrorX()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a5ca7171310a4637e716b4c129695bc17">IND_Entity2d::setMirrorY()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a3a85d26de9dc9e4083507d7660362eae">IND_Entity2d::setFilter()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a7cbf96ce94827ef15a95c8e3a159094a">IND_Entity2d::setHotSpot()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a2132c2148e1c4104160c6ac1c3368fa0">IND_Entity2d::setRegion()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1424e885e0fe91b8a22a1df8aa88f388">IND_Entity2d::toggleWrap()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga42fe9fd8e6c7e379bb0262f9140acd52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setTransform2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>pTransformMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pTransformMatrix</b> Translation Matrix (IND_Matrix) to apply to render</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function sets the 2d transformation (via transformation Matrix) of the following 2d graphical objects that will be rendered by the engine. You should use this method before calling to any of the Bliting methods.</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity2d.html">IND_Entity2d</a> object for applying 2d transformations to the graphical objects without having to use this advanced method directly. This method is only useful for advanced users with really concrete purposes. This method only modifies the view-world transform. In other words, it doesn't modify camera transformations that you have in place, just object transforms inside your world.</p>
<p>Using this method is equivalent to using a combination of these methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity2d.html#aef59718436b8814bbe436896881981a4">IND_Entity2d::setAnimation()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1ab0eff38c9b443a753af7127ec07468">IND_Entity2d::setSurface()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#af13ad8c40136fbe861675d979a59af78">IND_Entity2d::setPrimitive2d()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#ae30979e23720efc0dd55dd5d4e3c86c5">IND_Entity2d::setFont()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a262307147825572fcdaf3325929e4b1d">IND_Entity2d::setPosition()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#acdf17679ee28eea4072e53b4f588ca15">IND_Entity2d::setAngleXYZ()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#af98e3c6e7b068566bd88f97616b4b44c">IND_Entity2d::setScale()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a9955b77af097d21ccf7612b970a3e86d">IND_Entity2d::setBackCull()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a4159b55c2684982f9495b06ce8c42504">IND_Entity2d::setMirrorX()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a5ca7171310a4637e716b4c129695bc17">IND_Entity2d::setMirrorY()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a3a85d26de9dc9e4083507d7660362eae">IND_Entity2d::setFilter()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a7cbf96ce94827ef15a95c8e3a159094a">IND_Entity2d::setHotSpot()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a2132c2148e1c4104160c6ac1c3368fa0">IND_Entity2d::setRegion()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a1424e885e0fe91b8a22a1df8aa88f388">IND_Entity2d::toggleWrap()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="gade4886167d26425f28e73e347bbc98e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::setTransform3d </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pAngleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pAngleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pAngleZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScaleZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> *&#160;</td>
          <td class="paramname"><em>pMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pX</b> Translation in the X coordinate. </li>
<li><b>pY</b> Translation in the Y coordinate. </li>
<li><b>pZ</b> Translation in the Z coordinate. </li>
<li><b>pAngleX</b> Rotation in the angle x in degrees </li>
<li><b>pAngleY</b> Rotation in the angle y in degrees </li>
<li><b>pAngleZ</b> Rotation in the angle z in degrees </li>
<li><b>pScaleX</b> Scaling in the x coordinate. 1 to maintain the original size </li>
<li><b>pScaleY</b> Scaling in the y coordinate. 1 to maintain the original size </li>
<li><b>pScaleZ</b> Scaling in the z coordinate. 1 to maintain the original size </li>
<li><b>pMatrix</b> Pointer to a <a class="el" href="group___additional.html#gaf486c298edce0d5a57d53383b3b5627f" title="Matrix 4x4  (_11, _21, _31, _41,  _12, _22, _32, _42,  _13, _23, _33, _43  _14, _24, _34, _44)">IND_Matrix</a> matrix. In this parameter will be returned by reference the world matrix transformation that will be aplied to the graphical object. This matrix can be useful for advanced programmers that need the algebraic description of the transformation done. It is possible to use the value 0 if it not necessary to have this matrix information. <b>Operation:</b> </li>
</ul>
<p>This function sets the 3d transformation (translation, rotation, scaling and mirroring) of the following 3d graphical objects that will be rendered by the engine. You should use this method before calling to any of the Bliting methods.</p>
<p>Remember that you can use <a class="el" href="class_i_n_d___entity3d.html">IND_Entity3d</a> object for applying 3d transformations to the graphical objects without having to use this advanced method directly. This method is only useful for advanced users for really concrete purposes.</p>
<p>This method is equivalent to use a combination of this methods:</p>
<ul>
<li><a class="el" href="class_i_n_d___entity3d.html#a953e4a04bb064446273ba8659e9f427a">IND_Entity3d::set3dMesh()</a></li>
<li><a class="el" href="class_i_n_d___entity3d.html#aa4dc90eb43a8b8f4ab09928e5be625e0">IND_Entity3d::setPosition()</a></li>
<li><a class="el" href="class_i_n_d___entity3d.html#af4761913599a03e3aa96b4f96eaac90d">IND_Entity3d::setAngleXYZ()</a></li>
<li><a class="el" href="class_i_n_d___entity3d.html#ab0d98ec2d20db99abd61a48b85044d03">IND_Entity3d::setScale()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a9955b77af097d21ccf7612b970a3e86d">IND_Entity2d::setBackCull()</a></li>
<li><a class="el" href="class_i_n_d___entity2d.html#a3a85d26de9dc9e4083507d7660362eae">IND_Entity2d::setFilter()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga974b11cf130e67ec1166e9903cb6ee1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Render::setViewPort2d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pX</b> Upper left X coordinate of the Viewport </li>
<li><b>pY</b> Upper left Y coordinate of the Viewport </li>
<li><b>pWidth</b> Viewport width </li>
<li><b>pHeight</b> Viewport height</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function returns 1 (true) if a 2d ViewPort is created in the specified area.</p>
<p>The ViewPort is the drawing region. By default, <a class="el" href="class_indie_lib.html">IndieLib</a> is initialized with a Viewport that has the same area as the window. Using this method you can define different viewports before calling to <a class="el" href="class_i_n_d___entity2d_manager.html#aa1de62ea7e3b0cda9c5580979640e1af">IND_Entity2dManager::renderEntities2d()</a>.</p>
<p>After using this method, all the bliting methods will render the graphical objects inside the Viewport. Objects or blocks drawn outside the viewport will be discarded.</p>
<p>This method returns 0 (false) if the user tries to create a Viewport outside the window area. </p>

</div>
</div>
<a class="anchor" id="ga287a12952c58833d70825d4170469b2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Render::setViewPort3d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Parameters:</b> </p>
<ul>
<li><b>pX</b> Upper left X coordinate of the Viewport </li>
<li><b>pY</b> Upper left Y coordinate of the Viewport </li>
<li><b>pWidth</b> Viewport width </li>
<li><b>pHeight</b> Viewport height</li>
</ul>
<p><b>Operation:</b> </p>
<p>This function returns 1 (true) if a 3d ViewPort is created in the specified area.</p>
<p>The ViewPort is the drawing region. You have to call to this method before calling to <a class="el" href="class_i_n_d___entity3d_manager.html#a8fffedda764fb296f9828feb86e9500f">IND_Entity3dManager::renderEntities3d()</a>.</p>
<p>After using this method, all the 3d bliting methods will render the graphical objects inside this Viewport.</p>
<p>This method returns 0 (false) if the user tries to create a Viewport outside the window area. </p>

</div>
</div>
<a class="anchor" id="gaf8763d2eea657cb37567d306eaf91e31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Render::showFpsInWindowTitle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Operation:</b> </p>
<p>This function shows the fps (frames per second) as the title of the window.</p>
<p>NOTE: The updating of the window title is quite time-consuming, so this is not the correct method for checking the FPS. It's better to use the methods <a class="el" href="group___graphical___objects.html#ga216b992b23ee70382f8fbb8b28831ddc" title="This function returns the actual fps (frames per second) in an int.">IND_Render::getFpsInt()</a> or <a class="el" href="group___graphical___objects.html#ga119d9e65701018180070cb9a6df5d21f">IND_Render::getFpsString()</a> and drawing the result using an <a class="el" href="class_i_n_d___font.html">IND_Font</a> object. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 9 2012 21:51:52 for Indielib cross-platform by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
